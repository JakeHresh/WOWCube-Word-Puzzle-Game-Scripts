// This PAWN script is generated by WOWCube SDK project wizard

#define G2D

#pragma warning disable 203
#pragma warning disable 213
#pragma warning disable 229

// Includes
// -----------------------------

#include "wowcore.inc"
#include "topology.inc"
#include "graphics.inc"
#include "motion_sensor.inc"
#include "math.inc"
#include "console.inc"
#include "log.inc"
// This import contains the 4-letter word collection as a 1D array.
#include "WordCollection.inc"
#include "random.inc"
//#include "requests.inc"
#include "vars.inc"
// Application defines
// -----------------------------
#define TEXT_SIZE       24

new imageMode = true;

new rotated = true;

scramble_r(rotation_count)
{
    for (new i = 0; i < rotation_count; i++)
    {
        new white_val1 = white[2];
        new white_val2 = white[6]
        new green_val1 = green[2];
        new green_val2 = green[6];
        new yellow_val1 = yellow[2];
        new yellow_val2 = yellow[6];
        new blue_val1 = blue[2];
        new blue_val2 = blue[6];
        new red_val1 = red[0];
        new red_val2 = red[2];
        new red_val3 = red[4];
        new red_val4 = red[6];

        white[2] = green_val1;
        white[6] = green_val2;

        green[2] = yellow_val1;
        green[6] = yellow_val2;

        yellow[2] = blue_val1;
        yellow[6] = blue_val2;

        blue[2] = white_val1;
        blue[6] = white_val2;

        red[0] = red_val3;
        red[2] = red_val1;
        red[4] = red_val4;
        red[6] = red_val2;
    }
}

scramble_l(rotation_count)
{
    for (new i = 0; i < rotation_count; i++)
    {
        new white_val1 = white[0];
        new white_val2 = white[4]
        new green_val1 = green[0];
        new green_val2 = green[4];
        new yellow_val1 = yellow[0];
        new yellow_val2 = yellow[4];
        new blue_val1 = blue[0];
        new blue_val2 = blue[4];
        new orange_val1 = orange[0];
        new orange_val2 = orange[2];
        new orange_val3 = orange[4];
        new orange_val4 = orange[6];

        white[0] = blue_val1;
        white[4] = blue_val2;

        green[0] = white_val1;
        green[4] = white_val2;

        yellow[0] = green_val1;
        yellow[4] = green_val2;

        blue[0] = yellow_val1;
        blue[4] = yellow_val2;

        orange[0] = orange_val3;
        orange[2] = orange_val1;
        orange[4] = orange_val4;
        orange[6] = orange_val2;
    }
}

scramble_u(rotation_count)
{
    for (new i = 0; i < rotation_count; i++)
    {
        new white_val1 = white[0];
        new white_val2 = white[2];
        new white_val3 = white[4];
        new white_val4 = white[6];
        new green_val1 = green[0];
        new green_val2 = green[2];
        new blue_val1 = blue[4];
        new blue_val2 = blue[6];
        new red_val1 = red[2];
        new red_val2 = red[6];
        new orange_val1 = orange[2];
        new orange_val2 = orange[6];

        white[0] = white_val3;
        white[2] = white_val1;
        white[4] = white_val4;
        white[6] = white_val2;

        green[0] = red_val1;
        green[2] = red_val2;

        blue[4] = orange_val2;
        blue[6] = orange_val1;

        red[2] = blue_val2;
        red[6] = blue_val1;

        orange[2] = green_val1;
        orange[6] = green_val2;
    }
}

scramble_d(rotation_count)
{
    for (new i = 0; i < rotation_count; i++)
    {
        new green_val1 = green[4];
        new green_val2 = green[6];
        new yellow_val1 = yellow[0]; 
        new yellow_val2 = yellow[2];
        new yellow_val3 = yellow[4];
        new yellow_val4 = yellow[6];
        new blue_val1 = blue[0];
        new blue_val2 = blue[2];
        new red_val1 = red[0];
        new red_val2 = red[4];
        new orange_val1 = orange[0];
        new orange_val2 = orange[4];

        green[4] = orange_val1;
        green[6] = orange_val2;

        yellow[0] = yellow_val3;
        yellow[2] = yellow_val1;
        yellow[4] = yellow_val4;
        yellow[6] = yellow_val2;

        blue[0] = red_val2;
        blue[2] = red_val1;

        red[0] = green_val1;
        red[4] = green_val2;

        orange[0] = blue_val2;
        orange[4] = blue_val1;
    }
}

scramble_f(rotation_count)
{
    for (new i = 0; i < rotation_count; i++)
    {
        new white_val1 = white[4];
        new white_val2 = white[6];
        new green_val1 = green[0]; 
        new green_val2 = green[2];
        new green_val3 = green[4];
        new green_val4 = green[6];
        new yellow_val1 = yellow[0];
        new yellow_val2 = yellow[2];
        new red_val1 = red[0];
        new red_val2 = red[2];
        new orange_val1 = orange[4];
        new orange_val2 = orange[6];

        white[4] = orange_val1;
        white[6] = orange_val2;

        green[0] = green_val3;
        green[2] = green_val1;
        green[4] = green_val4
        green[6] = green_val2

        yellow[0] = red_val1;
        yellow[2] = red_val2;

        red[0] = white_val2;
        red[2] = white_val1;

        orange[4] = yellow_val2;
        orange[6] = yellow_val1;
    }
}

scramble_b(rotation_count)
{
    for (new i = 0; i < rotation_count; i++)
    {
        new white_val1 = white[0];
        new white_val2 = white[2];
        new yellow_val1 = yellow[4];
        new yellow_val2 = yellow[6];
        new blue_val1 = blue[0]; 
        new blue_val2 = blue[2];
        new blue_val3 = blue[4];
        new blue_val4 = blue[6];
        new red_val1 = red[4];
        new red_val2 = red[6];
        new orange_val1 = orange[0];
        new orange_val2 = orange[2];

        white[0] = red_val2;
        white[2] = red_val1;

        yellow[4] = orange_val2;
        yellow[6] = orange_val1;

        blue[0] = blue_val3;
        blue[2] = blue_val1;
        blue[4] = blue_val4;
        blue[6] = blue_val2;

        red[4] = yellow_val1;
        red[6] = yellow_val2;

        orange[0] = white_val1;
        orange[2] = white_val2;
    }
}

// WOWCube application callbacks 
// -----------------------------

//Applicaton initialization callback. Called once when CUB application starts
public ON_Init(id, size, const pkt[])
{
    game_mode = 1;
    word1Index = RND_randomize(0, 25)
    do {
        word2Index = RND_randomize(0, 25)
    } while(word2Index == word1Index);
    do {
        word3Index = RND_randomize(0, 25)
    } while(word3Index == word2Index || word3Index == word1Index);
    do {
        word4Index = RND_randomize(0, 25)
    } while(word4Index == word3Index || word4Index == word2Index || word4Index == word1Index);
    do {
        word5Index = RND_randomize(0, 25)
    } while(word5Index == word4Index || word5Index == word3Index || word5Index == word2Index || word5Index == word1Index);
    do {
        word6Index = RND_randomize(0, 25)
    } while(word6Index == word5Index || word6Index == word4Index || word6Index == word3Index || word6Index == word2Index || word6Index == word1Index);
    // To pick the word you want from the array, consider this formula:
    // wordIndex * 8
    // To pick a specific letter from a specific word, consider this formula:
    // wordIndex * 8 + letterIndex
    white[0] = letter_collection[word1Index]
    white[2] = letter_collection[word1Index]
    white[4] = letter_collection[word1Index]
    white[6] = letter_collection[word1Index]

    green[0] = letter_collection[word2Index]
    green[2] = letter_collection[word2Index]
    green[4] = letter_collection[word2Index]
    green[6] = letter_collection[word2Index]

    yellow[0] = letter_collection[word3Index]
    yellow[2] = letter_collection[word3Index]
    yellow[4] = letter_collection[word3Index]
    yellow[6] = letter_collection[word3Index]

    blue[0] = letter_collection[word4Index]
    blue[2] = letter_collection[word4Index]
    blue[4] = letter_collection[word4Index]
    blue[6] = letter_collection[word4Index]

    red[0] = letter_collection[word5Index]
    red[2] = letter_collection[word5Index]
    red[4] = letter_collection[word5Index]
    red[6] = letter_collection[word5Index]

    orange[0] = letter_collection[word6Index]
    orange[2] = letter_collection[word6Index]
    orange[4] = letter_collection[word6Index]
    orange[6] = letter_collection[word6Index]

    for (new i = 0; i < 7; i++)
    {
        scramble_r(RND_randomize(0, 4));
        scramble_l(RND_randomize(0, 4));
        scramble_u(RND_randomize(0, 4));
        scramble_d(RND_randomize(0, 4));
        scramble_f(RND_randomize(0, 4));
        scramble_b(RND_randomize(0, 4));
    }

    // Below code sets the top face to the white values.
    new place[TOPOLOGY_PLACE];
    new face = TOPOLOGY_getFace(ORIENTATION_UP);

    for(new screenNumber = 0; screenNumber<3; screenNumber++)
    {
        for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
        {
            place.face = face;
            place.position = screenPositionIndex;

            facelet = TOPOLOGY_getFacelet(place);
            switch(screenPositionIndex)
            { 
                case 0: {drawn_facelet_collection[0 * 4 + 0] = facelet.screen; drawn_facelet_collection[0 * 4 + 1] = facelet.module; drawn_facelet_collection[0 * 4 + 2] = white[0];}
                case 1: {drawn_facelet_collection[1 * 4 + 0] = facelet.screen; drawn_facelet_collection[1 * 4 + 1] = facelet.module; drawn_facelet_collection[1 * 4 + 2] = white[2];}
                case 2: {drawn_facelet_collection[3 * 4 + 0] = facelet.screen; drawn_facelet_collection[3 * 4 + 1] = facelet.module; drawn_facelet_collection[3 * 4 + 2] = white[6];}
                case 3: {drawn_facelet_collection[2 * 4 + 0] = facelet.screen; drawn_facelet_collection[2 * 4 + 1] = facelet.module; drawn_facelet_collection[2 * 4 + 2] = white[4];}
            }
        }
    }
    // Yellow values
    face = TOPOLOGY_getFace(ORIENTATION_DOWN);
    for(new screenNumber = 0; screenNumber<3; screenNumber++)
    {
        for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
        {
            place.face = face;
            place.position = screenPositionIndex;

            facelet = TOPOLOGY_getFacelet(place);
            switch(screenPositionIndex)
            { 
                case 0: {drawn_facelet_collection[9 * 4 + 0] = facelet.screen; drawn_facelet_collection[9 * 4 + 1] = facelet.module; drawn_facelet_collection[9 * 4 + 2] = yellow[2];}
                case 1: {drawn_facelet_collection[11 * 4 + 0] = facelet.screen; drawn_facelet_collection[11 * 4 + 1] = facelet.module; drawn_facelet_collection[11 * 4 + 2] = yellow[6];}
                case 2: {drawn_facelet_collection[10 * 4 + 0] = facelet.screen; drawn_facelet_collection[10 * 4 + 1] = facelet.module; drawn_facelet_collection[10 * 4 + 2] = yellow[4];}
                case 3: {drawn_facelet_collection[8 * 4 + 0] = facelet.screen; drawn_facelet_collection[8 * 4 + 1] = facelet.module; drawn_facelet_collection[8 * 4 + 2] = yellow[0];}
            }
        }
    }
    // Maybe I can just find the adjacent/opposite screen/module pairings using the built-in functions
    new reference_facelet[TOPOLOGY_FACELET];

    // Greens
    reference_facelet.screen = drawn_facelet_collection[2 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[2 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[4 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[4 * 4 + 1] = facelet.module;
    drawn_facelet_collection[4 * 4 + 2] = green[0];

    reference_facelet.screen = drawn_facelet_collection[3 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[3 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[5 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[5 * 4 + 1] = facelet.module;
    drawn_facelet_collection[5 * 4 + 2] = green[2];

    reference_facelet.screen = drawn_facelet_collection[8 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[8 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[6 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[6 * 4 + 1] = facelet.module;
    drawn_facelet_collection[6 * 4 + 2] = green[4];

    reference_facelet.screen = drawn_facelet_collection[9 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[9 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[7 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[7 * 4 + 1] = facelet.module;
    drawn_facelet_collection[7 * 4 + 2] = green[6];

    // Reds
    reference_facelet.screen = drawn_facelet_collection[3 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[3 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[17 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[17 * 4 + 1] = facelet.module;
    drawn_facelet_collection[17 * 4 + 2] = red[2];

    reference_facelet.screen = drawn_facelet_collection[1 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[1 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[19 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[19 * 4 + 1] = facelet.module;
    drawn_facelet_collection[19 * 4 + 2] = red[6];

    reference_facelet.screen = drawn_facelet_collection[9 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[9 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[16 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[16 * 4 + 1] = facelet.module;
    drawn_facelet_collection[16 * 4 + 2] = red[0];

    reference_facelet.screen = drawn_facelet_collection[11 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[11 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[18 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[18 * 4 + 1] = facelet.module;
    drawn_facelet_collection[18 * 4 + 2] = red[4];

    // Blues
    reference_facelet.screen = drawn_facelet_collection[1 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[1 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[15 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[15 * 4 + 1] = facelet.module;
    drawn_facelet_collection[15 * 4 + 2] = blue[6];

    reference_facelet.screen = drawn_facelet_collection[0 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[0 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[14 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[14 * 4 + 1] = facelet.module;
    drawn_facelet_collection[14 * 4 + 2] = blue[4];

    reference_facelet.screen = drawn_facelet_collection[11 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[11 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[13 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[13 * 4 + 1] = facelet.module;
    drawn_facelet_collection[13 * 4 + 2] = blue[2];

    reference_facelet.screen = drawn_facelet_collection[10 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[10 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[12 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[12 * 4 + 1] = facelet.module;
    drawn_facelet_collection[12 * 4 + 2] = blue[0];

    // Oranges
    reference_facelet.screen = drawn_facelet_collection[0 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[0 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[21 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[21 * 4 + 1] = facelet.module;
    drawn_facelet_collection[21 * 4 + 2] = orange[2];
    
    reference_facelet.screen = drawn_facelet_collection[2 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[2 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[23 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[23 * 4 + 1] = facelet.module;
    drawn_facelet_collection[23 * 4 + 2] = orange[6];

    reference_facelet.screen = drawn_facelet_collection[10 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[10 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    drawn_facelet_collection[20 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[20 * 4 + 1] = facelet.module;
    drawn_facelet_collection[20 * 4 + 2] = orange[0];

    reference_facelet.screen = drawn_facelet_collection[8 * 4 + 0];
    reference_facelet.module = drawn_facelet_collection[8 * 4 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    drawn_facelet_collection[22 * 4 + 0] = facelet.screen;
    drawn_facelet_collection[22 * 4 + 1] = facelet.module;
    drawn_facelet_collection[22 * 4 + 2] = orange[4];

    for(new i = 0; i < 24; i++)
    {
        LOG_w("Screen: %d", drawn_facelet_collection[i * 4 + 0]);
        LOG_w("Module: %d", drawn_facelet_collection[i * 4 + 1]);
        LOG_w("Letter: %c", drawn_facelet_collection[i * 4 + 2])
    }

    /*scramble_r(1);
        scramble_l(2);
        scramble_u(1);
        scramble_d(2);
        scramble_f(2);
        scramble_b(1)*/

    /*
    Based on my notes, the Screen-Module Pairings should look like this:
        // Shows as red in testing
        0 G1 = Screen 0, Module 3
        2 G2 = Screen 0, Module 0
        4 G3 = Screen 0, Module 2
        6 G4 = Screen 0, Module 1
        
        0 Y1 = Screen 2, Module 2 // Shows as blue in testing
        2 Y2 = Screen 1, Module 1 // Shows as green in testing
        4 Y3 = Screen 1, Module 7 // Shows as green in testing
        6 Y4 = Screen 2, Module 4 // Shows as blue in testing

        // Shows as red in testing
        0 B1 = Screen 0, Module 7 
        2 B2 = Screen 0, Module 4
        4 B3 = Screen 0, Module 6
        6 B4 = Screen 0, Module 5

        0 W1 = Screen 2, Module 6 // Shows as blue in testing
        2 W2 = Screen 1, Module 5 // Shows as green in testing
        4 W3 = Screen 1, Module 3 // Shows as green in testing
        6 W4 = Screen 2, Module 0 // Shows as blue in testing

        0 R1 = Screen 2, Module 1 // Shows as blue in testing
        2 R2 = Screen 1, Module 0 // Shows as green in testing
        4 R3 = Screen 1, Module 4 // Shows as green in testing
        6 R4 = Screen 2, Module 5 // Shows as blue in testing

        0 O1 = Screen 2, Module 7 // Shows as blue in testing
        2 O2 = Screen 1, Module 6 // Shows as green in testing
        4 O3 = Screen 1, Module 2 // Shows as green in testing
        6 O4 = Screen 2, Module 3 // Shows as blue in testing
    */
}

//Saved application state data load callback. Gets called in response to loadState() function call
public ON_Load(id, size, const pkt[]) 
{

}

//Main run loop callback. Gets called recurrently by the CUB application as frequent as application code allows. 
public ON_Tick()
{
    //******************** */
    // Below code sets the top face to the white values.
    new place[TOPOLOGY_PLACE];
    new face = TOPOLOGY_getFace(ORIENTATION_UP);

    for(new screenNumber = 0; screenNumber<3; screenNumber++)
    {
        for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
        {
            place.face = face;
            place.position = screenPositionIndex;

            facelet = TOPOLOGY_getFacelet(place);
            switch(screenPositionIndex)
            { 
                case 0: {direction_facelet_collection[0 * 5 + 0] = facelet.screen; direction_facelet_collection[0 * 5 + 1] = facelet.module;}
                case 1: {direction_facelet_collection[1 * 5 + 0] = facelet.screen; direction_facelet_collection[1 * 5 + 1] = facelet.module;}
                case 2: {direction_facelet_collection[3 * 5 + 0] = facelet.screen; direction_facelet_collection[3 * 5 + 1] = facelet.module;}
                case 3: {direction_facelet_collection[2 * 5 + 0] = facelet.screen; direction_facelet_collection[2 * 5 + 1] = facelet.module;}
            }
        }
    }
    // Yellow values
    face = TOPOLOGY_getFace(ORIENTATION_DOWN);
    for(new screenNumber = 0; screenNumber<3; screenNumber++)
    {
        for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
        {
            place.face = face;
            place.position = screenPositionIndex;

            facelet = TOPOLOGY_getFacelet(place);
            switch(screenPositionIndex)
            { 
                case 0: {direction_facelet_collection[9 * 5 + 0] = facelet.screen; direction_facelet_collection[9 * 5 + 1] = facelet.module;}
                case 1: {direction_facelet_collection[11 * 5 + 0] = facelet.screen; direction_facelet_collection[11 * 5 + 1] = facelet.module;}
                case 2: {direction_facelet_collection[10 * 5 + 0] = facelet.screen; direction_facelet_collection[10 * 5 + 1] = facelet.module;}
                case 3: {direction_facelet_collection[8 * 5 + 0] = facelet.screen; direction_facelet_collection[8 * 5 + 1] = facelet.module;}
            }
        }
    }
    
    new reference_facelet[TOPOLOGY_FACELET];

    // Greens
    reference_facelet.screen = direction_facelet_collection[2 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[2 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[4 * 5 + 0] = facelet.screen;
    direction_facelet_collection[4 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[3 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[3 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[5 * 5 + 0] = facelet.screen;
    direction_facelet_collection[5 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[8 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[8 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[6 * 5 + 0] = facelet.screen;
    direction_facelet_collection[6 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[9 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[9 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[7 * 5 + 0] = facelet.screen;
    direction_facelet_collection[7 * 5 + 1] = facelet.module;

    // Reds
    reference_facelet.screen = direction_facelet_collection[3 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[3 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[17 * 5 + 0] = facelet.screen;
    direction_facelet_collection[17 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[1 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[1 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[19 * 5 + 0] = facelet.screen;
    direction_facelet_collection[19 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[9 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[9 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[16 * 5 + 0] = facelet.screen;
    direction_facelet_collection[16 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[11 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[11 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[18 * 5 + 0] = facelet.screen;
    direction_facelet_collection[18 * 5 + 1] = facelet.module;

    // Blues
    reference_facelet.screen = direction_facelet_collection[1 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[1 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[15 * 5 + 0] = facelet.screen;
    direction_facelet_collection[15 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[0 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[0 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[14 * 5 + 0] = facelet.screen;
    direction_facelet_collection[14 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[11 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[11 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[13 * 5 + 0] = facelet.screen;
    direction_facelet_collection[13 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[10 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[10 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[12 * 5 + 0] = facelet.screen;
    direction_facelet_collection[12 * 5 + 1] = facelet.module;

    // Oranges
    reference_facelet.screen = direction_facelet_collection[0 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[0 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[21 * 5 + 0] = facelet.screen;
    direction_facelet_collection[21 * 5 + 1] = facelet.module;
    
    reference_facelet.screen = direction_facelet_collection[2 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[2 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[23 * 5 + 0] = facelet.screen;
    direction_facelet_collection[23 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[10 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[10 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
    direction_facelet_collection[20 * 5 + 0] = facelet.screen;
    direction_facelet_collection[20 * 5 + 1] = facelet.module;

    reference_facelet.screen = direction_facelet_collection[8 * 5 + 0];
    reference_facelet.module = direction_facelet_collection[8 * 5 + 1];
    facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
    direction_facelet_collection[22 * 5 + 0] = facelet.screen;
    direction_facelet_collection[22 * 5 + 1] = facelet.module;
    if(game_mode != 2)
    {
        for(new i = 0; i < 24; i++)
        {
            for(new j = 0; j < 24; j++)
            {
                if (direction_facelet_collection[i * 5 + 1] == drawn_facelet_collection[j * 4 + 1] && direction_facelet_collection[i * 5 + 0] == drawn_facelet_collection[j * 4 + 0])
                {
                    direction_facelet_collection[i * 5 + 2] = drawn_facelet_collection[j * 4 + 2];
                }
            }
        }
        for(new i = 0; i < 24; i += 4)
        {
            new arr1[] = [-1, -1, -1, -1];
            new arr2[] = [-1, -1, -1, -1];
            new arr3[] = [-1, -1, -1, -1];
            new arr4[] = [-1, -1, -1, -1];

            arr1[0] = direction_facelet_collection[(i + 0) * 5 + 2]; arr1[1] = direction_facelet_collection[(i + 1) * 5 + 2]; arr1[2] = direction_facelet_collection[(i + 2) * 5 + 2]; arr1[3] = direction_facelet_collection[(i + 3) * 5 + 2];
            arr2[0] = direction_facelet_collection[(i + 2) * 5 + 2]; arr2[1] = direction_facelet_collection[(i + 0) * 5 + 2]; arr2[2] = direction_facelet_collection[(i + 3) * 5 + 2]; arr2[3] = direction_facelet_collection[(i + 1) * 5 + 2];
            arr3[0] = direction_facelet_collection[(i + 3) * 5 + 2]; arr3[1] = direction_facelet_collection[(i + 2) * 5 + 2]; arr3[2] = direction_facelet_collection[(i + 1) * 5 + 2]; arr3[3] = direction_facelet_collection[(i + 0) * 5 + 2];
            arr4[0] = direction_facelet_collection[(i + 1) * 5 + 2]; arr4[1] = direction_facelet_collection[(i + 3) * 5 + 2]; arr4[2] = direction_facelet_collection[(i + 0) * 5 + 2]; arr4[3] = direction_facelet_collection[(i + 2) * 5 + 2];
            
            if(rotated)
            {
                LOG_w("%c%c%c%c", arr1[0], arr1[1], arr1[2], arr1[3]);
                LOG_w("---");
                LOG_w("%c%c%c%c", arr2[0], arr2[1], arr2[2], arr2[3]);
                LOG_w("---");
                LOG_w("%c%c%c%c", arr3[0], arr3[1], arr3[2], arr3[3]);
                LOG_w("---");
                LOG_w("%c%c%c%c", arr4[0], arr4[1], arr4[2], arr4[3]);
                LOG_w("---");
                LOG_w("---");
            }
            
            for(new j = 0; j < 3129; j++)
            {
                if(arr1[0] == words[j * 8 + 0] && arr1[1] == words[j * 8 + 2] && arr1[2] == words[j * 8 + 4] && arr1[3] == words[j * 8 + 6])
                {
                    solved[i/4] = true;
                    j = 3129;
                }
                else if(arr2[0] == words[j * 8 + 0] && arr2[1] == words[j * 8 + 2] && arr2[2] == words[j * 8 + 4] && arr2[3] == words[j * 8 + 6])
                {
                    solved[i/4] = true;
                    j = 3129;
                }
                else if(arr3[0] == words[j * 8 + 0] && arr3[1] == words[j * 8 + 2] && arr3[2] == words[j * 8 + 4] && arr3[3] == words[j * 8 + 6])
                {
                    solved[i/4] = true;
                    j = 3129;
                }
                else if(arr4[0] == words[j * 8 + 0] && arr4[1] == words[j * 8 + 2] && arr4[2] == words[j * 8 + 4] && arr4[3] == words[j * 8 + 6])
                {
                    solved[i/4] = true;
                    j = 3129;
                }
                // Check for solution for standard 2x2x2 cube
                else if(arr1[0] == arr1[1] && arr1[1] == arr1[2] && arr1[2] == arr1[3])
                {
                    solved[i/4] = true;
                    j = 3129;
                }
                else
                {
                    solved[i/4] = false;
                }
            }
        }
        
        if(solved[0] && solved[1] && solved[2] && solved[3] && solved[4] && solved[5])
        {
            for(new i = 0; i < 24; i++)
            {
                drawn_facelet_collection[i * 4 + 3] = 0;
            }
        }
        else
        {
            for(new i = 0; i < 24; i++)
            {
                drawn_facelet_collection[i * 4 + 3] = 1;
            }
        }
        if(rotated)
        {
            LOG_w("%d, %d, %d, %d, %d, %d", solved[0], solved[1], solved[2], solved[3], solved[4], solved[5])
            LOG_w("Finished checking")
        }
        
    }
    else if(game_mode == 2)
    {
        for(new i = 0; i < 24; i++)
        {
            for(new j = 0; j < 24; j++)
            {
                if (direction_facelet_collection[i * 5 + 1] == mode_three_collection[j * 5 + 1] && direction_facelet_collection[i * 5 + 0] == mode_three_collection[j * 5 + 0])
                {
                    direction_facelet_collection[i * 5 + 2] = mode_three_collection[j * 5 + 2];
                    direction_facelet_collection[i * 5 + 3] = mode_three_collection[j * 5 + 3];
                    direction_facelet_collection[i * 5 + 4] = mode_three_collection[j * 5 + 4];
                }
            }
        }
        for(new i = 0; i < 24; i += 4)
        {
            new solvable = false;

            new arr1[] = [-1, -1, -1, -1];
            new arr2[] = [-1, -1, -1, -1];
            new arr3[] = [-1, -1, -1, -1];
            new arr4[] = [-1, -1, -1, -1];

            arr1[0] = direction_facelet_collection[(i + 0) * 5 + 2]; arr1[1] = direction_facelet_collection[(i + 1) * 5 + 2]; arr1[2] = direction_facelet_collection[(i + 2) * 5 + 2]; arr1[3] = direction_facelet_collection[(i + 3) * 5 + 2];
            arr2[0] = direction_facelet_collection[(i + 2) * 5 + 2]; arr2[1] = direction_facelet_collection[(i + 0) * 5 + 2]; arr2[2] = direction_facelet_collection[(i + 3) * 5 + 2]; arr2[3] = direction_facelet_collection[(i + 1) * 5 + 2];
            arr3[0] = direction_facelet_collection[(i + 3) * 5 + 2]; arr3[1] = direction_facelet_collection[(i + 2) * 5 + 2]; arr3[2] = direction_facelet_collection[(i + 1) * 5 + 2]; arr3[3] = direction_facelet_collection[(i + 0) * 5 + 2];
            arr4[0] = direction_facelet_collection[(i + 1) * 5 + 2]; arr4[1] = direction_facelet_collection[(i + 3) * 5 + 2]; arr4[2] = direction_facelet_collection[(i + 0) * 5 + 2]; arr4[3] = direction_facelet_collection[(i + 2) * 5 + 2];
            
            if(rotated)
            {
                LOG_w("%c%c%c%c", arr1[0], arr1[1], arr1[2], arr1[3]);
                LOG_w("---");
                LOG_w("%c%c%c%c", arr2[0], arr2[1], arr2[2], arr2[3]);
                LOG_w("---");
                LOG_w("%c%c%c%c", arr3[0], arr3[1], arr3[2], arr3[3]);
                LOG_w("---");
                LOG_w("%c%c%c%c", arr4[0], arr4[1], arr4[2], arr4[3]);
                LOG_w("---");
                LOG_w("---");
            }

            if(direction_facelet_collection[(i + 0) * 5 + 4] == 1 && direction_facelet_collection[(i + 1) * 5 + 3] == 90 && direction_facelet_collection[(i + 2) * 5 + 3] == 270 && direction_facelet_collection[(i + 3) * 5 + 3] == 0)
            {
                solvable = true;
            }
            else if(direction_facelet_collection[(i + 2) * 5 + 4] == 1 && direction_facelet_collection[(i + 0) * 5 + 3] == 90 && direction_facelet_collection[(i + 3) * 5 + 3] == 270 && direction_facelet_collection[(i + 1) * 5 + 3] == 0)
            {
                solvable = true;
            }
            else if(direction_facelet_collection[(i + 3) * 5 + 4] == 1 && direction_facelet_collection[(i + 2) * 5 + 3] == 90 && direction_facelet_collection[(i + 1) * 5 + 3] == 270 && direction_facelet_collection[(i + 0) * 5 + 3] == 0)
            {
                solvable = true;
            }
            else if(direction_facelet_collection[(i + 1) * 5 + 4] == 1 && direction_facelet_collection[(i + 3) * 5 + 3] == 90 && direction_facelet_collection[(i + 0) * 5 + 3] == 270 && direction_facelet_collection[(i + 2) * 5 + 3] == 0)
            {
                solvable = true;
            }
            else
            {
                solved[i/4] = false;
            }

            if(solvable)
            {
                for(new j = 0; j < 3129; j++)
                {
                    if(arr1[0] == words[j * 8 + 0] && arr1[1] == words[j * 8 + 2] && arr1[2] == words[j * 8 + 4] && arr1[3] == words[j * 8 + 6])
                    {
                        solved[i/4] = true;
                        j = 3129;
                    }
                    else if(arr2[0] == words[j * 8 + 0] && arr2[1] == words[j * 8 + 2] && arr2[2] == words[j * 8 + 4] && arr2[3] == words[j * 8 + 6])
                    {
                        solved[i/4] = true;
                        j = 3129;
                    }
                    else if(arr3[0] == words[j * 8 + 0] && arr3[1] == words[j * 8 + 2] && arr3[2] == words[j * 8 + 4] && arr3[3] == words[j * 8 + 6])
                    {
                        solved[i/4] = true;
                        j = 3129;
                    }
                    else if(arr4[0] == words[j * 8 + 0] && arr4[1] == words[j * 8 + 2] && arr4[2] == words[j * 8 + 4] && arr4[3] == words[j * 8 + 6])
                    {
                        solved[i/4] = true;
                        j = 3129;
                    }
                    else
                    {
                        solved[i/4] = false;
                    }
                }
            }
        }
    }
    rotated = false;
}

//This callback gets called immediately after ON_Tick(). Use it for calling your rendering code. 
public ON_Render()
{
    GFX_setRenderTarget(0);
    drawCubeLetter(0);
    GFX_render();

    GFX_setRenderTarget(1);
    drawCubeLetter(1);
    GFX_render();

    GFX_setRenderTarget(2);
    drawCubeLetter(2);
    GFX_render();
}


//The "physics" callback. Gets called recurrently with 30ms resolution. 
public ON_PhysicsTick() 
{
}

//The "inner network" callback. Gets called when WOWCube module receives a data packet from other module
public ON_Message(const pkt[MESSAGE_SIZE])
{
}

//The cube topology change callback. Gets called when cube is twisted and its topological description has been changed
public ON_Twist(twist[TOPOLOGY_TWIST_INFO]) 
{    
    rotated = true;
}

//Device shake detection callback.
public ON_Shake(const count) 
{
    quit();
    if (count == 4)
    {
        //quit();
    }
    else if (count == 1)
    {
       // Use this else statement to have the player check if the cube is solved. 
    }
}

//Screen tap callback.
public ON_Tap(const count, const display, const bool:opposite) 
{
    // Switch between game modes and resetting on the fly.
    /*if(count == 1)
    {
        imageMode = !imageMode;
    }*/
    if(count == 2)
    {
        // The word solving game
        game_mode = 0;
        rotated = true;
        word1Index = RND_randomize(0, 3129)
        do {
            word2Index = RND_randomize(0, 3129)
        } while(word2Index == word1Index);
        do {
            word3Index = RND_randomize(0, 3129)
        } while(word3Index == word2Index || word3Index == word1Index);
        do {
            word4Index = RND_randomize(0, 3129)
        } while(word4Index == word3Index || word4Index == word2Index || word4Index == word1Index);
        do {
            word5Index = RND_randomize(0, 3129)
        } while(word5Index == word4Index || word5Index == word3Index || word5Index == word2Index || word5Index == word1Index);
        do {
            word6Index = RND_randomize(0, 3129)
        } while(word6Index == word5Index || word6Index == word4Index || word6Index == word3Index || word6Index == word2Index || word6Index == word1Index);
        // To pick the word you want from the array, consider this formula:
        // wordIndex * 8
        // To pick a specific letter from a specific word, consider this formula:
        // wordIndex * 8 + letterIndex
        white[0] = words[word1Index * 8 + 0]
        white[2] = words[word1Index * 8 + 2]
        white[4] = words[word1Index * 8 + 4]
        white[6] = words[word1Index * 8 + 6]

        green[0] = words[word2Index * 8 + 0]
        green[2] = words[word2Index * 8 + 2]
        green[4] = words[word2Index * 8 + 4]
        green[6] = words[word2Index * 8 + 6]

        yellow[0] = words[word3Index * 8 + 0]
        yellow[2] = words[word3Index * 8 + 2]
        yellow[4] = words[word3Index * 8 + 4]
        yellow[6] = words[word3Index * 8 + 6]

        blue[0] = words[word4Index * 8 + 0]
        blue[2] = words[word4Index * 8 + 2]
        blue[4] = words[word4Index * 8 + 4]
        blue[6] = words[word4Index * 8 + 6]

        red[0] = words[word5Index * 8 + 0]
        red[2] = words[word5Index * 8 + 2]
        red[4] = words[word5Index * 8 + 4]
        red[6] = words[word5Index * 8 + 6]

        orange[0] = words[word6Index * 8 + 0]
        orange[2] = words[word6Index * 8 + 2]
        orange[4] = words[word6Index * 8 + 4]
        orange[6] = words[word6Index * 8 + 6]

        for (new i = 0; i < 7; i++)
        {
            scramble_r(RND_randomize(0, 4));
            scramble_l(RND_randomize(0, 4))
            scramble_u(RND_randomize(0, 4));
            scramble_d(RND_randomize(0, 4));
            scramble_f(RND_randomize(0, 4));
            scramble_b(RND_randomize(0, 4));
        }

        /*scramble_r(1);
        scramble_l(2);
        scramble_u(1);
        scramble_d(2);
        scramble_f(2);
        scramble_b(1)*/

        // Below code sets the top face to the white values.
        new place[TOPOLOGY_PLACE];
        new face = TOPOLOGY_getFace(ORIENTATION_UP);

        for(new screenNumber = 0; screenNumber<3; screenNumber++)
        {
            for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
            {
                place.face = face;
                place.position = screenPositionIndex;

                facelet = TOPOLOGY_getFacelet(place);
                switch(screenPositionIndex)
                { 
                    case 0: {
                        drawn_facelet_collection[0 * 4 + 0] = facelet.screen; 
                        drawn_facelet_collection[0 * 4 + 1] = facelet.module; 
                        drawn_facelet_collection[0 * 4 + 2] = white[0];
                    }
                    case 1: {
                        drawn_facelet_collection[1 * 4 + 0] = facelet.screen; 
                        drawn_facelet_collection[1 * 4 + 1] = facelet.module; 
                        drawn_facelet_collection[1 * 4 + 2] = white[2];
                    }
                    case 2: {
                        drawn_facelet_collection[3 * 4 + 0] = facelet.screen; 
                        drawn_facelet_collection[3 * 4 + 1] = facelet.module; 
                        drawn_facelet_collection[3 * 4 + 2] = white[6];
                    }
                    case 3: {
                        drawn_facelet_collection[2 * 4 + 0] = facelet.screen; 
                        drawn_facelet_collection[2 * 4 + 1] = facelet.module; 
                        drawn_facelet_collection[2 * 4 + 2] = white[4];
                    }
                }
            }
        }
        // Yellow values
        face = TOPOLOGY_getFace(ORIENTATION_DOWN);
        for(new screenNumber = 0; screenNumber<3; screenNumber++)
        {
            for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
            {
                place.face = face;
                place.position = screenPositionIndex;

                facelet = TOPOLOGY_getFacelet(place);
                switch(screenPositionIndex)
                { 
                    case 0: {drawn_facelet_collection[9 * 4 + 0] = facelet.screen; drawn_facelet_collection[9 * 4 + 1] = facelet.module; drawn_facelet_collection[9 * 4 + 2] = yellow[2];}
                    case 1: {drawn_facelet_collection[11 * 4 + 0] = facelet.screen; drawn_facelet_collection[11 * 4 + 1] = facelet.module; drawn_facelet_collection[11 * 4 + 2] = yellow[6];}
                    case 2: {drawn_facelet_collection[10 * 4 + 0] = facelet.screen; drawn_facelet_collection[10 * 4 + 1] = facelet.module; drawn_facelet_collection[10 * 4 + 2] = yellow[4];}
                    case 3: {drawn_facelet_collection[8 * 4 + 0] = facelet.screen; drawn_facelet_collection[8 * 4 + 1] = facelet.module; drawn_facelet_collection[8 * 4 + 2] = yellow[0];}
                }
            }
        }
        // Maybe I can just find the adjacent/opposite screen/module pairings using the built-in functions
        new reference_facelet[TOPOLOGY_FACELET];

        // Greens
        reference_facelet.screen = drawn_facelet_collection[2 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[2 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[4 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[4 * 4 + 1] = facelet.module;
        drawn_facelet_collection[4 * 4 + 2] = green[0];

        reference_facelet.screen = drawn_facelet_collection[3 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[3 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[5 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[5 * 4 + 1] = facelet.module;
        drawn_facelet_collection[5 * 4 + 2] = green[2];

        reference_facelet.screen = drawn_facelet_collection[8 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[8 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[6 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[6 * 4 + 1] = facelet.module;
        drawn_facelet_collection[6 * 4 + 2] = green[4];

        reference_facelet.screen = drawn_facelet_collection[9 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[9 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[7 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[7 * 4 + 1] = facelet.module;
        drawn_facelet_collection[7 * 4 + 2] = green[6];

        // Reds
        reference_facelet.screen = drawn_facelet_collection[3 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[3 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[17 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[17 * 4 + 1] = facelet.module;
        drawn_facelet_collection[17 * 4 + 2] = red[2];

        reference_facelet.screen = drawn_facelet_collection[1 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[1 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[19 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[19 * 4 + 1] = facelet.module;
        drawn_facelet_collection[19 * 4 + 2] = red[6];

        reference_facelet.screen = drawn_facelet_collection[9 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[9 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[16 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[16 * 4 + 1] = facelet.module;
        drawn_facelet_collection[16 * 4 + 2] = red[0];

        reference_facelet.screen = drawn_facelet_collection[11 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[11 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[18 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[18 * 4 + 1] = facelet.module;
        drawn_facelet_collection[18 * 4 + 2] = red[4];

        // Blues
        reference_facelet.screen = drawn_facelet_collection[1 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[1 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[15 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[15 * 4 + 1] = facelet.module;
        drawn_facelet_collection[15 * 4 + 2] = blue[6];

        reference_facelet.screen = drawn_facelet_collection[0 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[0 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[14 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[14 * 4 + 1] = facelet.module;
        drawn_facelet_collection[14 * 4 + 2] = blue[4];

        reference_facelet.screen = drawn_facelet_collection[11 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[11 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[13 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[13 * 4 + 1] = facelet.module;
        drawn_facelet_collection[13 * 4 + 2] = blue[2];

        reference_facelet.screen = drawn_facelet_collection[10 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[10 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[12 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[12 * 4 + 1] = facelet.module;
        drawn_facelet_collection[12 * 4 + 2] = blue[0];

        // Oranges
        reference_facelet.screen = drawn_facelet_collection[0 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[0 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[21 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[21 * 4 + 1] = facelet.module;
        drawn_facelet_collection[21 * 4 + 2] = orange[2];
        
        reference_facelet.screen = drawn_facelet_collection[2 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[2 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[23 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[23 * 4 + 1] = facelet.module;
        drawn_facelet_collection[23 * 4 + 2] = orange[6];

        reference_facelet.screen = drawn_facelet_collection[10 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[10 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[20 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[20 * 4 + 1] = facelet.module;
        drawn_facelet_collection[20 * 4 + 2] = orange[0];

        reference_facelet.screen = drawn_facelet_collection[8 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[8 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[22 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[22 * 4 + 1] = facelet.module;
        drawn_facelet_collection[22 * 4 + 2] = orange[4];

        for(new i = 0; i < 24; i++)
        {
            LOG_w("Screen: %d", drawn_facelet_collection[i * 4 + 0]);
            LOG_w("Module: %d", drawn_facelet_collection[i * 4 + 1]);
            LOG_w("Letter: %c", drawn_facelet_collection[i * 4 + 2])
        }
    }
    if(count == 3)
    {
        // The standard 2x2x2 with symbols solving game
        rotated = true;
        game_mode = 1;
        word1Index = RND_randomize(0, 25)
        do {
            word2Index = RND_randomize(0, 25)
        } while(word2Index == word1Index);
        do {
            word3Index = RND_randomize(0, 25)
        } while(word3Index == word2Index || word3Index == word1Index);
        do {
            word4Index = RND_randomize(0, 25)
        } while(word4Index == word3Index || word4Index == word2Index || word4Index == word1Index);
        do {
            word5Index = RND_randomize(0, 25)
        } while(word5Index == word4Index || word5Index == word3Index || word5Index == word2Index || word5Index == word1Index);
        do {
            word6Index = RND_randomize(0, 25)
        } while(word6Index == word5Index || word6Index == word4Index || word6Index == word3Index || word6Index == word2Index || word6Index == word1Index);
        // To pick the word you want from the array, consider this formula:
        // wordIndex * 8
        // To pick a specific letter from a specific word, consider this formula:
        // wordIndex * 8 + letterIndex
        white[0] = letter_collection[word1Index]
        white[2] = letter_collection[word1Index]
        white[4] = letter_collection[word1Index]
        white[6] = letter_collection[word1Index]

        green[0] = letter_collection[word2Index]
        green[2] = letter_collection[word2Index]
        green[4] = letter_collection[word2Index]
        green[6] = letter_collection[word2Index]

        yellow[0] = letter_collection[word3Index]
        yellow[2] = letter_collection[word3Index]
        yellow[4] = letter_collection[word3Index]
        yellow[6] = letter_collection[word3Index]

        blue[0] = letter_collection[word4Index]
        blue[2] = letter_collection[word4Index]
        blue[4] = letter_collection[word4Index]
        blue[6] = letter_collection[word4Index]

        red[0] = letter_collection[word5Index]
        red[2] = letter_collection[word5Index]
        red[4] = letter_collection[word5Index]
        red[6] = letter_collection[word5Index]

        orange[0] = letter_collection[word6Index]
        orange[2] = letter_collection[word6Index]
        orange[4] = letter_collection[word6Index]
        orange[6] = letter_collection[word6Index]

        for (new i = 0; i < 7; i++)
        {
            scramble_r(RND_randomize(0, 4));
            scramble_l(RND_randomize(0, 4))
            scramble_u(RND_randomize(0, 4));
            scramble_d(RND_randomize(0, 4));
            scramble_f(RND_randomize(0, 4));
            scramble_b(RND_randomize(0, 4));
        }

        // Below code sets the top face to the white values.
        new place[TOPOLOGY_PLACE];
        new face = TOPOLOGY_getFace(ORIENTATION_UP);

        for(new screenNumber = 0; screenNumber<3; screenNumber++)
        {
            for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
            {
                place.face = face;
                place.position = screenPositionIndex;

                facelet = TOPOLOGY_getFacelet(place);
                switch(screenPositionIndex)
                { 
                    case 0: {drawn_facelet_collection[0 * 4 + 0] = facelet.screen; drawn_facelet_collection[0 * 4 + 1] = facelet.module; drawn_facelet_collection[0 * 4 + 2] = white[0];}
                    case 1: {drawn_facelet_collection[1 * 4 + 0] = facelet.screen; drawn_facelet_collection[1 * 4 + 1] = facelet.module; drawn_facelet_collection[1 * 4 + 2] = white[2];}
                    case 2: {drawn_facelet_collection[3 * 4 + 0] = facelet.screen; drawn_facelet_collection[3 * 4 + 1] = facelet.module; drawn_facelet_collection[3 * 4 + 2] = white[6];}
                    case 3: {drawn_facelet_collection[2 * 4 + 0] = facelet.screen; drawn_facelet_collection[2 * 4 + 1] = facelet.module; drawn_facelet_collection[2 * 4 + 2] = white[4];}
                }
            }
        }
        // Yellow values
        face = TOPOLOGY_getFace(ORIENTATION_DOWN);
        for(new screenNumber = 0; screenNumber<3; screenNumber++)
        {
            for (new screenPositionIndex = 0; screenPositionIndex < TOPOLOGY_POSITIONS_MAX; screenPositionIndex++) 
            {
                place.face = face;
                place.position = screenPositionIndex;

                facelet = TOPOLOGY_getFacelet(place);
                switch(screenPositionIndex)
                { 
                    case 0: {drawn_facelet_collection[9 * 4 + 0] = facelet.screen; drawn_facelet_collection[9 * 4 + 1] = facelet.module; drawn_facelet_collection[9 * 4 + 2] = yellow[2];}
                    case 1: {drawn_facelet_collection[11 * 4 + 0] = facelet.screen; drawn_facelet_collection[11 * 4 + 1] = facelet.module; drawn_facelet_collection[11 * 4 + 2] = yellow[6];}
                    case 2: {drawn_facelet_collection[10 * 4 + 0] = facelet.screen; drawn_facelet_collection[10 * 4 + 1] = facelet.module; drawn_facelet_collection[10 * 4 + 2] = yellow[4];}
                    case 3: {drawn_facelet_collection[8 * 4 + 0] = facelet.screen; drawn_facelet_collection[8 * 4 + 1] = facelet.module; drawn_facelet_collection[8 * 4 + 2] = yellow[0];}
                }
            }
        }
        // Maybe I can just find the adjacent/opposite screen/module pairings using the built-in functions
        new reference_facelet[TOPOLOGY_FACELET];

        // Greens
        reference_facelet.screen = drawn_facelet_collection[2 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[2 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[4 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[4 * 4 + 1] = facelet.module;
        drawn_facelet_collection[4 * 4 + 2] = green[0];

        reference_facelet.screen = drawn_facelet_collection[3 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[3 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[5 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[5 * 4 + 1] = facelet.module;
        drawn_facelet_collection[5 * 4 + 2] = green[2];

        reference_facelet.screen = drawn_facelet_collection[8 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[8 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[6 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[6 * 4 + 1] = facelet.module;
        drawn_facelet_collection[6 * 4 + 2] = green[4];

        reference_facelet.screen = drawn_facelet_collection[9 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[9 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[7 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[7 * 4 + 1] = facelet.module;
        drawn_facelet_collection[7 * 4 + 2] = green[6];

        // Reds
        reference_facelet.screen = drawn_facelet_collection[3 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[3 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[17 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[17 * 4 + 1] = facelet.module;
        drawn_facelet_collection[17 * 4 + 2] = red[2];

        reference_facelet.screen = drawn_facelet_collection[1 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[1 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[19 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[19 * 4 + 1] = facelet.module;
        drawn_facelet_collection[19 * 4 + 2] = red[6];

        reference_facelet.screen = drawn_facelet_collection[9 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[9 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[16 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[16 * 4 + 1] = facelet.module;
        drawn_facelet_collection[16 * 4 + 2] = red[0];

        reference_facelet.screen = drawn_facelet_collection[11 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[11 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[18 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[18 * 4 + 1] = facelet.module;
        drawn_facelet_collection[18 * 4 + 2] = red[4];

        // Blues
        reference_facelet.screen = drawn_facelet_collection[1 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[1 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[15 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[15 * 4 + 1] = facelet.module;
        drawn_facelet_collection[15 * 4 + 2] = blue[6];

        reference_facelet.screen = drawn_facelet_collection[0 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[0 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[14 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[14 * 4 + 1] = facelet.module;
        drawn_facelet_collection[14 * 4 + 2] = blue[4];

        reference_facelet.screen = drawn_facelet_collection[11 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[11 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[13 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[13 * 4 + 1] = facelet.module;
        drawn_facelet_collection[13 * 4 + 2] = blue[2];

        reference_facelet.screen = drawn_facelet_collection[10 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[10 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[12 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[12 * 4 + 1] = facelet.module;
        drawn_facelet_collection[12 * 4 + 2] = blue[0];

        // Oranges
        reference_facelet.screen = drawn_facelet_collection[0 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[0 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[21 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[21 * 4 + 1] = facelet.module;
        drawn_facelet_collection[21 * 4 + 2] = orange[2];
        
        reference_facelet.screen = drawn_facelet_collection[2 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[2 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[23 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[23 * 4 + 1] = facelet.module;
        drawn_facelet_collection[23 * 4 + 2] = orange[6];

        reference_facelet.screen = drawn_facelet_collection[10 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[10 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_BOTTOM);
        drawn_facelet_collection[20 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[20 * 4 + 1] = facelet.module;
        drawn_facelet_collection[20 * 4 + 2] = orange[0];

        reference_facelet.screen = drawn_facelet_collection[8 * 4 + 0];
        reference_facelet.module = drawn_facelet_collection[8 * 4 + 1];
        facelet = TOPOLOGY_getAdjacentFacelet(reference_facelet, NEIGHBOR_RIGHT);
        drawn_facelet_collection[22 * 4 + 0] = facelet.screen;
        drawn_facelet_collection[22 * 4 + 1] = facelet.module;
        drawn_facelet_collection[22 * 4 + 2] = orange[4];

        for(new i = 0; i < 24; i++)
        {
            LOG_w("Screen: %d", drawn_facelet_collection[i * 4 + 0]);
            LOG_w("Module: %d", drawn_facelet_collection[i * 4 + 1]);
            LOG_w("Letter: %c", drawn_facelet_collection[i * 4 + 2])
        }
    }
    if(count == 4)
    {
        // The strict symbol/word solving game
        rotated = true;
        game_mode = 2;
        // Will rely on the hard-coded screen-module pairings.
        word1Index = RND_randomize(0, 3129)
        do {
            word2Index = RND_randomize(0, 3129)
        } while(word2Index == word1Index);
        do {
            word3Index = RND_randomize(0, 3129)
        } while(word3Index == word2Index || word3Index == word1Index);
        do {
            word4Index = RND_randomize(0, 3129)
        } while(word4Index == word3Index || word4Index == word2Index || word4Index == word1Index);
        do {
            word5Index = RND_randomize(0, 3129)
        } while(word5Index == word4Index || word5Index == word3Index || word5Index == word2Index || word5Index == word1Index);
        do {
            word6Index = RND_randomize(0, 3129)
        } while(word6Index == word5Index || word6Index == word4Index || word6Index == word3Index || word6Index == word2Index || word6Index == word1Index);
        // To pick the word you want from the array, consider this formula:
        // wordIndex * 8
        // To pick a specific letter from a specific word, consider this formula:
        // wordIndex * 8 + letterIndex
        white[0] = words[word1Index * 8 + 0]
        white[2] = words[word1Index * 8 + 2]
        white[4] = words[word1Index * 8 + 4]
        white[6] = words[word1Index * 8 + 6]

        green[0] = words[word2Index * 8 + 0]
        green[2] = words[word2Index * 8 + 2]
        green[4] = words[word2Index * 8 + 4]
        green[6] = words[word2Index * 8 + 6]

        yellow[0] = words[word3Index * 8 + 0]
        yellow[2] = words[word3Index * 8 + 2]
        yellow[4] = words[word3Index * 8 + 4]
        yellow[6] = words[word3Index * 8 + 6]

        blue[0] = words[word4Index * 8 + 0]
        blue[2] = words[word4Index * 8 + 2]
        blue[4] = words[word4Index * 8 + 4]
        blue[6] = words[word4Index * 8 + 6]

        red[0] = words[word5Index * 8 + 0]
        red[2] = words[word5Index * 8 + 2]
        red[4] = words[word5Index * 8 + 4]
        red[6] = words[word5Index * 8 + 6]

        orange[0] = words[word6Index * 8 + 0]
        orange[2] = words[word6Index * 8 + 2]
        orange[4] = words[word6Index * 8 + 4]
        orange[6] = words[word6Index * 8 + 6]

        // W1
        mode_three_collection[0 * 5 + 0] = 2;
        mode_three_collection[0 * 5 + 1] = 6;
        mode_three_collection[0 * 5 + 2] = white[0];
        mode_three_collection[0 * 5 + 3] = 180;
        mode_three_collection[0 * 5 + 4] = 1;

        mode_three_collection[1 * 5 + 0] = 1;
        mode_three_collection[1 * 5 + 1] = 5;
        mode_three_collection[1 * 5 + 2] = white[2];
        mode_three_collection[1 * 5 + 3] = 90;

        mode_three_collection[2 * 5 + 0] = 1;
        mode_three_collection[2 * 5 + 1] = 3;
        mode_three_collection[2 * 5 + 2] = white[4];
        mode_three_collection[2 * 5 + 3] = 270;

        mode_three_collection[3 * 5 + 0] = 2;
        mode_three_collection[3 * 5 + 1] = 0;
        mode_three_collection[3 * 5 + 2] = white[6];
        mode_three_collection[3 * 5 + 3] = 0;

        // G1
        mode_three_collection[4 * 5 + 0] = 0;
        mode_three_collection[4 * 5 + 1] = 3;
        mode_three_collection[4 * 5 + 2] = green[2];
        mode_three_collection[4 * 5 + 3] = 90;

        mode_three_collection[5 * 5 + 0] = 0;
        mode_three_collection[5 * 5 + 1] = 0;
        mode_three_collection[5 * 5 + 2] = green[6];
        mode_three_collection[5 * 5 + 3] = 0;

        mode_three_collection[6 * 5 + 0] = 0;
        mode_three_collection[6 * 5 + 1] = 2;
        mode_three_collection[6 * 5 + 2] = green[0];
        mode_three_collection[6 * 5 + 3] = 180;
        mode_three_collection[6 * 5 + 4] = 1;

        mode_three_collection[7 * 5 + 0] = 0;
        mode_three_collection[7 * 5 + 1] = 1;
        mode_three_collection[7 * 5 + 2] = green[4];
        mode_three_collection[7 * 5 + 3] = 270;

        // Y1
        mode_three_collection[8 * 5 + 0] = 2;
        mode_three_collection[8 * 5 + 1] = 2;
        mode_three_collection[8 * 5 + 2] = yellow[0];
        mode_three_collection[8 * 5 + 3] = 180;
        mode_three_collection[8 * 5 + 4] = 1;

        mode_three_collection[9 * 5 + 0] = 1;
        mode_three_collection[9 * 5 + 1] = 1;
        mode_three_collection[9 * 5 + 2] = yellow[2];
        mode_three_collection[9 * 5 + 3] = 90;

        mode_three_collection[10 * 5 + 0] = 1;
        mode_three_collection[10 * 5 + 1] = 7;
        mode_three_collection[10 * 5 + 2] = yellow[4];
        mode_three_collection[10 * 5 + 3] = 270;

        mode_three_collection[11 * 5 + 0] = 2;
        mode_three_collection[11 * 5 + 1] = 4;
        mode_three_collection[11 * 5 + 2] = yellow[6];
        mode_three_collection[11 * 5 + 3] = 0;

        // B1
        mode_three_collection[12 * 5 + 0] = 0;
        mode_three_collection[12 * 5 + 1] = 7;
        mode_three_collection[12 * 5 + 2] = blue[2];
        mode_three_collection[12 * 5 + 3] = 90;

        mode_three_collection[13 * 5 + 0] = 0;
        mode_three_collection[13 * 5 + 1] = 4;
        mode_three_collection[13 * 5 + 2] = blue[6];
        mode_three_collection[13 * 5 + 3] = 0;

        mode_three_collection[14 * 5 + 0] = 0;
        mode_three_collection[14 * 5 + 1] = 6;
        mode_three_collection[14 * 5 + 2] = blue[0];
        mode_three_collection[14 * 5 + 3] = 180;
        mode_three_collection[14 * 5 + 4] = 1;

        mode_three_collection[15 * 5 + 0] = 0;
        mode_three_collection[15 * 5 + 1] = 5;
        mode_three_collection[15 * 5 + 2] = blue[4];
        mode_three_collection[15 * 5 + 3] = 270;

        // R1
        mode_three_collection[16 * 5 + 0] = 2;
        mode_three_collection[16 * 5 + 1] = 1;
        mode_three_collection[16 * 5 + 2] = red[0];
        mode_three_collection[16 * 5 + 3] = 180;
        mode_three_collection[16 * 5 + 4] = 1;

        mode_three_collection[17 * 5 + 0] = 1;
        mode_three_collection[17 * 5 + 1] = 0;
        mode_three_collection[17 * 5 + 2] = red[2];
        mode_three_collection[17 * 5 + 3] = 90;

        mode_three_collection[18 * 5 + 0] = 1;
        mode_three_collection[18 * 5 + 1] = 4;
        mode_three_collection[18 * 5 + 2] = red[4];
        mode_three_collection[18 * 5 + 3] = 270;

        mode_three_collection[19 * 5 + 0] = 2;
        mode_three_collection[19 * 5 + 1] = 5;
        mode_three_collection[19 * 5 + 2] = red[6];
        mode_three_collection[19 * 5 + 3] = 0;

        // O1
        mode_three_collection[20 * 5 + 0] = 2;
        mode_three_collection[20 * 5 + 1] = 7;
        mode_three_collection[20 * 5 + 2] = orange[0];
        mode_three_collection[20 * 5 + 3] = 180;
        mode_three_collection[20 * 5 + 4] = 1;

        mode_three_collection[21 * 5 + 0] = 1;
        mode_three_collection[21 * 5 + 1] = 6;
        mode_three_collection[21 * 5 + 2] = orange[2];
        mode_three_collection[21 * 5 + 3] = 90;

        mode_three_collection[22 * 5 + 0] = 1;
        mode_three_collection[22 * 5 + 1] = 2;
        mode_three_collection[22 * 5 + 2] = orange[4];
        mode_three_collection[22 * 5 + 3] = 270;

        mode_three_collection[23 * 5 + 0] = 2;
        mode_three_collection[23 * 5 + 1] = 3;
        mode_three_collection[23 * 5 + 2] = orange[6];
        mode_three_collection[23 * 5 + 3] = 0;
    }
}

//Application quit callback.
public ON_Quit()
{
    //
    //Save game data here
    //
}

// User-defined functions
// -----------------------------
drawCubeLetter(screen_number)
{
    for (new i = 0; i < 24; i++)
    {
        if (SELF_ID == drawn_facelet_collection[i * 4 + 1] && screen_number == drawn_facelet_collection[i * 4] && game_mode != 2)
        {
            GFX_drawImage([ 120,120 ], 0xFF, Colors.black, 0, MIRROR_BLANK, ((drawn_facelet_collection[i * 4 + 2] - 97) * 2) + drawn_facelet_collection[i * 4 + 3]);
            if(!imageMode)
            {
                if(drawn_facelet_collection[i * 4 + 3] == 1)
                {
                    GFX_drawRectangleXY(56, 56, 128, 128, Colors.black);
                }
                else
                {
                    GFX_drawRectangleXY(56, 56, 128, 128, Colors.white);
                }
            }
        }
        else if((SELF_ID == mode_three_collection[i * 5 + 1] && screen_number == mode_three_collection[i * 5]) && game_mode == 2)
        {
            // This is for the unsolved rendering. Have the colors be inverted for the solved rendering.
            if(i < 4 || (i > 7 && i < 12) || i > 15)
            {
                if(solved[0] && solved[1] && solved[2] && solved[3] && solved[4] && solved[5])
                {
                    GFX_clear(Colors.white);
                    if(i % 4 == 0)
                    {
                        GFX_drawText([ 120,80], TEXT_SIZE, 180, 0, TEXT_ALIGN_CENTER, Colors.red, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 1)
                    {
                        GFX_drawText([ 80,120], TEXT_SIZE, 90, 0, TEXT_ALIGN_CENTER, Colors.black, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 2)
                    {
                        GFX_drawText([ 200,120], TEXT_SIZE, 270, 0, TEXT_ALIGN_CENTER, Colors.black, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 3)
                    {
                        GFX_drawText([ 120,200], TEXT_SIZE, 0, 0, TEXT_ALIGN_CENTER, Colors.black, "%c", mode_three_collection[i * 5 + 2]);
                    }
                }
                else
                {
                    GFX_clear(Colors.black);
                    if(i % 4 == 0)
                    {
                        GFX_drawText([ 120,80], TEXT_SIZE, 180, 0, TEXT_ALIGN_CENTER, Colors.yellow, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 1)
                    {
                        GFX_drawText([ 80,120], TEXT_SIZE, 90, 0, TEXT_ALIGN_CENTER, Colors.white, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 2)
                    {
                        GFX_drawText([ 200,120], TEXT_SIZE, 270, 0, TEXT_ALIGN_CENTER, Colors.white, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 3)
                    {
                        GFX_drawText([ 120,200], TEXT_SIZE, 0, 0, TEXT_ALIGN_CENTER, Colors.white, "%c", mode_three_collection[i * 5 + 2]);
                    }
                }
            }
            else
            {
                if(solved[0] && solved[1] && solved[2] && solved[3] && solved[4] && solved[5])
                {
                    GFX_clear(Colors.white);
                    if(i % 4 == 0)
                    {
                        GFX_drawText([ 80,120], TEXT_SIZE, 90, 0, TEXT_ALIGN_CENTER, Colors.black, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 1)
                    {
                        GFX_drawText([ 120,200], TEXT_SIZE, 0, 0, TEXT_ALIGN_CENTER, Colors.black, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 2)
                    {
                        GFX_drawText([ 120,80], TEXT_SIZE, 180, 0, TEXT_ALIGN_CENTER, Colors.red, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 3)
                    {
                        GFX_drawText([ 200,120], TEXT_SIZE, 270, 0, TEXT_ALIGN_CENTER, Colors.black, "%c", mode_three_collection[i * 5 + 2]);
                    }
                }
                else
                {
                    GFX_clear(Colors.black);
                    if(i % 4 == 0)
                    {
                        GFX_drawText([ 80,120], TEXT_SIZE, 90, 0, TEXT_ALIGN_CENTER, Colors.white, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 1)
                    {
                        GFX_drawText([ 120,200], TEXT_SIZE, 0, 0, TEXT_ALIGN_CENTER, Colors.white, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 2)
                    {
                        GFX_drawText([ 120,80], TEXT_SIZE, 180, 0, TEXT_ALIGN_CENTER, Colors.yellow, "%c", mode_three_collection[i * 5 + 2]);
                    }
                    else if(i % 4 == 3)
                    {
                        GFX_drawText([ 200,120], TEXT_SIZE, 270, 0, TEXT_ALIGN_CENTER, Colors.white, "%c", mode_three_collection[i * 5 + 2]);
                    }
                }
            }
        }
    }
}